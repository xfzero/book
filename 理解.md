1. 数据库长连接和短连接
长连接：每次执行结束后不会自动释放连接
短连接：每次执行结束后自动断开连接
一般数据库访问很频繁的情况下才会考虑使用长连接（如每秒钟连接几百上千次）

2. 前后端分离
传统的方式:提出需求->UI做出设计图->前端工程师做html页面->后端工程师将html页面套成jsp页面，并和服务接口集成->测试上线->遇到问题，此时前端就不好调试
前后端分离：提出需求->UI做出设计图->后端约定接口&数据&参数->前后端并行开发

半分离模式：
分离：增加node.js作为中间层，让controller层在前端手里，将页面所需要的多个后端数据，直接在内网阶段就拼装好，再统一返回给前端，会得到更好的性能

前端项目通过ajax、nodejs服务器等调用后端项目的接口

客户端请求页面、交互->node前端服务器（中间层）->转发给后端->后端处理后返回结果给node前端服务器->node前端服务器返回页面、更新数据

用nginx来做反向代理，负责转发请求，根据客户端访问的url把这个请求转发到不同的服务，比如访问/api/xxx的请求，就转发到后台服务，访问其它的请求，就转发到nodejs服务
全部通过nodejs服务器


后端变化：
return view()
return json()

可能会有跨域的问题，采用nginx代理、CORS等方式解决
一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。JSONP的方式也被淘汰掉了。

优势：
实现前后端解耦
在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），内网使用http，性能和安全都有保障

3. 加密
3.1 对称加密：
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。对称性加密也称为密钥加密。

对称加密通常使用的是相对较小的密钥，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1 MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。密钥的大小既要照顾到安全性，也要照顾到效率，是一个trade-off。

对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。

虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。为了解释这个过程，请看下面的例子：
（1） Alice需要在银行的网站做一笔交易，她的浏览器首先生成了一个随机数作为对称密钥。
（2） Alice的浏览器向银行的网站请求公钥。
（3） 银行将公钥发送给Alice。
（4） Alice的浏览器使用银行的公钥将自己的对称密钥加密。
（5） Alice的浏览器将加密后的对称密钥发送给银行。
（6） 银行使用私钥解密得到Alice浏览器的对称密钥。
（7） Alice与银行可以使用对称密钥来对沟通的内容进行加密与解密了。

3.2 非对称加密
非对称加密算法是一种密钥的保密方法。

非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。

另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；甲方再用自己的私钥对乙方发送回来的数据进行验签。

甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。

非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了。这样安全性就大了很多。

（1）A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。
（2）A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。
（3）A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。
（4）A将这个消息发给B（已经用B的公钥加密消息）。
（5）B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。

3.3 速度：
对称加密加密解密都使用相同的密钥（privatekey），算法比较快；
非对称加密机密和解密使用不同的密钥(privatekey,publickey)，算法比较慢；

3.4 单向加密
单向加密又称为不可逆加密，即生成密文无法反解的一种加密方式；
所以对称和非对称加密使用的算法都是双向加密；

3.5 数字签名
发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要,然后用自己的私人密钥对这个摘要进行加密，这个加密后的摘要将作为报文的数字签名和报文一起发送给接收方。
报文摘要A=md5(报文) -> sign = 私钥加密报文摘要A  -> 新的报文=报文+sign

接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公用密钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。
报文摘要B=md5(报文) -> 报文摘要C = 使用发送方的公钥解密sign  -> 如果 报文摘要C==报文摘要B 则证明报文就是发送方发送的，并且报文没有被篡改

数字签名有两种功效：
一是能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
二是数字签名能确定消息的完整性。
因为数字签名的特点是它代表了文件的特征，文件如果发生改变，数字摘要的值也将发生变化。不同的文件将得到不同的数字摘要。 一次数字签名涉及到一个哈希函数、发送者的公钥、发送者的私钥。

以上是对非对称加密的应用

数字签名和加密通信：
以上只用到了发送方的密钥，数据传输时还是明文的，如果需要加密传输，发送方可以使用接收方的公钥对数据进行加密再传输，接收方再使用自己的私钥将数据解密
签名可以确保发送方数据的完整性 和 可以证明消息确实是由发送方发送的，而加密通信再是保证了数据不以明文传输

变形：
发送方：signA=加密(报文+双方约定的私钥) -> 报文+singA 一起传输
接收方：signB=加密(报文+双方约定的私钥) -> 如果signA==singB 则确保报文没有被篡改，切发送方是可以向自己发送数据的

变形签名和对称加密通信：
二者选其一即可
如果不需要加密通信，则直接对称加密；如果传输的数据不需要加密，则用数字签名即可

3.6 总结
单向加密：通常用来传输类似用户名和密码
双向加密：对称加密+非对称加密，比较常用，一般用来隐秘通信
数字签名：双向加密通信没必要使用数字签名


4. 区块链
区块：
记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识；
是构成区块链的基本单元，他由包含原数据的区块头(记录当前区块的特征值)和包含交易数据的区块主体(实际数据)构成。

在整个区块链系统里，大约每十分钟就会创建一个区块，这个区块里面包含了这段时间全网范围内发生的所有交易，每一个区块也包含了前一个区块的识别码，这样以来就使得每一个区块都能找到他前面的一个节点，一直倒推就形成了一条完整的交易链条。

链：
由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录

节点：
节点分为“全节点”和“轻节点”，全节点就是拥有全网所有的交易数据的节点，那么轻节点就是只拥有和自己相关的交易数据节点。

矿机->矿场->矿池


5. 计算机启动过程
5.1）第一阶段：BIOS
上个世纪70年代初，"只读内存"（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。
这块芯片里的程序叫做"基本輸出輸入系統"（Basic Input/Output System），简称为BIOS。

硬件自检:
BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做"硬件自检"（Power-On Self-Test），缩写为POST。
如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。

启动顺序:
硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。
这时，BIOS需要知道，"下一阶段的启动程序"具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做"启动顺序"（Boot Sequence）。
打开BIOS的操作界面，里面有一项就是"设定启动顺序"。


5.2）第二阶段：主引导记录、
BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备。
这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给"启动顺序"中的下一个设备。
这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）。

主引导记录的结构：
"主引导记录"只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。
主引导记录由三个部分组成：
（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
其中，第二部分"分区表"的作用，是将硬盘分成若干个区

分区表：
硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，"主引导记录"因此必须知道将控制权转交给哪个区。
分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做"主分区"。
每个主分区的16个字节，由6个部分组成：
（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
最后的四个字节（"主分区的扇区总数"），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。
如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。


5.3）第三阶段：硬盘启动
这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。

情况A：卷引导记录
上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做"卷引导记录"（Volume boot record，缩写为VBR）。
"卷引导记录"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。

情况B：扩展分区和逻辑分区
随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成"扩展分区"（Extended partition）。
所谓"扩展分区"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做"逻辑分区"（logical partition）。
计算机先读取扩展分区的第一个扇区，叫做"扩展引导记录"（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。
计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。
但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。

情况C：启动管理器
在这种情况下，计算机读取"主引导记录"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的"启动管理器"（boot loader），由用户选择启动哪一个操作系统。


5.4）第四阶段：操作系统
控制权转交给操作系统后，操作系统的内核首先被载入内存。
以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。
然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。
至此，全部启动过程完成。


6. 第三方登录
拿QQ做例子，简单说一下流程：
当用户点击QQ登陆，你会通引导用户跳转到第三方登陆的登陆界面， 当用户成功登录以后会自动跳转回来，并附带一个code参数，接着你使用code就可以获得access token（访问令牌），对于QQ，由于第三方登录结合了Openid， 所以需要再通过token获取openid。

重点:这个openid是和QQ用户一一对应的, 使用access token + openid 即可获取用户信息。

为什么使用第三方登录：
那么为什么使用第三方登录, 服务方希望用户注册, 而用户懒得填注册时的各种信息(主要是为了保证用户的唯一性,各种用户名已占用,密码格式限制).而像微信, QQ, 微博等几乎每个人都会安装的应用中用户肯定会在其中某一个应用中已经注册过.证明该用户在已经注册的应用中的唯一性.
第三方登录的实质就是在授权时获得第三方应用提供的代表了用户在第三方应用中的唯一性的openid.并将openid储存在第三方服务控制的本地储存.

第三方登录与本地登录的关联
第三方平台和本地用户系统结合应该分为三种情况：
本地未登录，第一次登录第三方：此时相当于注册，直接把第三方信息拉取来并注册成本地用户就可以了，并建立本地用户与第三方用户（openid）的绑定关系
本地未登录，再次登录第三方：此时用户已注册，获取到openid后直接找出对应的本地用户即可
本地登录，并绑定第三方： 这个只要将获取到的openid绑定到本地用户就可以了

第三方登录解除授权实践：
已授权状态, 获取用户信息, 可直接获取.
解除授权后/未授权状态, 直接获取用户信息, 需要跳转到授权界面.

由此可以发现, 授权状态下,由第三方登录sdk控制的本地储存保存着 access token + openid.解除授权后,第三方sdk清除本地 access token + openid.

