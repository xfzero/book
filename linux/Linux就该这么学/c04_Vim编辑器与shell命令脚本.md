1. VIM文本编辑器
Vim 之所以能得到广大厂商与用户的认可，原因在于 Vim 编辑器中设置了三种模式—命令
模式、末行模式和编辑模式，每种模式分别又支持多种不同的命令快捷键，这大大提高了工
作效率，而且用户在习惯之后也会觉得相当顺手。要想高效率地操作文本，就必须先搞清这
三种模式的操作区别以及模式之间的切换方法（见图 4-1）。
➢ 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。
➢ 输入模式：正常的文本录入。
➢ 末行模式：保存或退出文档，以及设置编辑环境。

在每次运行 Vim 编辑器时，默认进入命令模式，此时需要先切换到输入模式后再进行文
档编写工作，而每次在编写完文档后需要先返回命令模式，然后再进入末行模式，执行文档
的保存或退出操作。在 Vim 中，无法直接从输入模式切换到末行模式。Vim 编辑器中内置的
命令有成百上千种用法，为了能够帮助读者更快地掌握 Vim 编辑器，表 4-1 总结了在命令模
式中最常用的一些命令。
Vim 中常用的命令：
dd 删除（剪切）光标所在整行
5dd 删除（剪切）从光标处开始的 5 行
yy 复制光标所在整行
5yy 复制从光标处开始的 5 行
n 显示搜索命令定位到的下一个字符串
N 显示搜索命令定位到的上一个字符串
u 撤销上一步的操作
p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面

末行模式主要用于保存或退出文件，以及设置 Vim 编辑器的工作环境，还可以让用户执
行外部的 Linux 命令或跳转到所编写文档的特定行数。要想切换到末行模式，在命令模式中
输入一个冒号就可以了。末行模式中可用的命令如表 4-2 所示。
末行模式中可用的命令：
:w 	保存
:q 	退出
:q! 	强制退出（放弃对文档的修改内容）
:wq! 	强制保存退出
:set nu 	显示行号
:set nonu 	不显示行号
:命令 	执行该命令
:整数 	跳转到该行
:s/one/two 	将当前光标所在行的第一个 one 替换成 two
:s/one/two/g 	将当前光标所在行的所有 one 替换成 two
:%s/one/two/g 	将全文中的所有 one 替换成 two
?字符串 		在文本中从下至上搜索该字符串
/字符串 		在文本中从上至下搜索该字符串


##1.1 编写简单文档


##1.2 配置主机名称
为了便于在局域网中查找某台特定的主机，或者对主机进行区分，除了要有 IP 地址外，
还要为主机配置一个主机名，主机之间可以通过这个类似于域名的名称来相互访问。在 Linux
系统中，主机名大多保存在/etc/hostname 文件中，接下来将/etc/hostname 文件的内容修改为
“linuxprobe.com”，步骤如下。

第1步：使用 Vim 编辑器修改“/etc/hostname”主机名称文件。
第2步：把原始主机名称删除后追加“linuxprobe.com”。注意，使用 Vim 编辑器修改主机名称文件后，
   要在末行模式下执行:wq!命令才能保存并退出文档。
第3步：保存并退出文档，然后使用 hostname 命令检查是否修改成功。

hostname 命令用于查看当前的主机名称，但有时主机名称的改变不会立即同步到系统中，
所以如果发现修改完成后还显示原来的主机名称，可重启虚拟机后再行查看：


##1.3 配置网卡信息
网卡 IP 地址配置的是否正确是两台服务器是否可以相互通信的前提。在 Linux 系统中，
一切都是文件，因此配置网络服务的工作其实就是在编辑网卡配置文件，因此这个小任务不
仅可以帮助您练习使用 Vim 编辑器，而且也为您后面学习 Linux 中的各种服务配置打下了坚
实的基础。当您认真学习完本书后，一定会特别有成就感，因为本书前面的基础部分非常扎
实，而后面内容则具有几乎一致的网卡 IP 地址和运行环境，从而确保您全身心地投入到各类
服务程序的学习上，而不用操心系统环境的问题。
如果您具备一定的运维经验或者熟悉早期的 Linux 系统，则在学习本书时会遇到一些不
容易接受的差异变化。在 RHEL 5、RHEL 6 中，网卡配置文件的前缀为 eth，第 1 块网卡为
eth0，第 2 块网卡为 eth1；以此类推。而在 RHEL 7 中，网卡配置文件的前缀则以 ifcfg 开始，
加上网卡名称共同组成了网卡配置文件的名字，例如 ifcfg-eno16777736；好在除了文件名变
化外也没有其他大的区别。
现在有一个名称为 ifcfg-eno16777736 的网卡设备，我们将其配置为开机自启动，并且 IP
地址、子网、网关等信息由人工指定，其步骤应该如下所示。

第1步：首先切换到/etc/sysconfig/network-scripts 目录中（存放着网卡的配置文件）。

第2步:使用 Vim 编辑器修改网卡文件 ifcfg-eno16777736，逐项写入下面的配置参数并
保存退出。由于每台设备的硬件及架构是不一样的，因此请读者使用 ifconfig 命令自行确认各
自网卡的默认名称。
➢ 设备类型：TYPE=Ethernet
➢ 地址分配模式：BOOTPROTO=static
➢ 网卡名称：NAME=eno16777736
➢ 是否启动：ONBOOT=yes
➢ IP 地址：IPADDR=192.168.10.10
➢ 子网掩码：NETMASK=255.255.255.0
➢ 网关地址：GATEWAY=192.168.10.1
➢ DNS 地址：DNS1=192.168.10.1

第3步：重启网络服务并测试网络是否联通。

进入到网卡配置文件所在的目录，然后编辑网卡配置文件，在其中填入下面的信息：
TYPE=Ethernet
BOOTPROTO=static
NAME=eno16777736
ONBOOT=yes
IPADDR=192.168.10.10
NETMASK=255.255.255.0
GATEWAY=192.168.10.1
DNS1=192.168.10.1

执行重启网卡设备的命令（在正常情况下不会有提示信息），然后通过 ping 命令测试网络能否
联通。由于在 Linux 系统中 ping 命令不会自动终止，因此需要手动按下 Ctrl-c 键来强行结束进程。
systemctl restart network
ping 192.168.10.10


##1.4 配置 Yum 软件仓库
本书前面讲到，Yum 软件仓库的作用是为了进一步简化 RPM 管理软件的难度以及自动分析
所需软件包及其依赖关系的技术。可以把 Yum 想象成是一个硕大的软件仓库，里面保存有几乎所
有常用的工具，而且只需要说出所需的软件包名称，系统就会自动为您搞定一切。
既然要使用 Yum 软件仓库，就要先把它搭建起来，然后将其配置规则确定好才行。鉴于
第 6 章才会讲解 Linux 的存储结构和设备挂载操作，所以我们当前还是将重心放到 Vim 编辑
器的学习上。如果遇到看不懂的参数也不要紧，后面章节会单独讲解。搭建并配置 Yum 软件
仓库的大致步骤如下所示。

第一步：进入到/etc/yum.repos.d/目录中（因为该目录存放着 Yum 软件仓库的配置文件）。

第二步：使用 Vim 编辑器创建一个名为 rhel7.repo 的新配置文件（文件名称可随意，但后
缀必须为.repo），逐项写入下面加粗的配置参数并保存退出（不要写后面的中文注释）。
➢ ：Yum 软件仓库唯一标识符，避免与其他仓库冲突。
➢ ：Yum 软件仓库的名称描述，易于识别仓库用处。
➢ ：提供的方式包括 FTP（ftp://..）、HTTP（http://..）、本地（file:///..）。
➢ ：设置此源是否可用；1 为可用，0 为禁用。
➢ ：设置此源是否校验文件；1 为校验，0 为不校验。
➢ ：若上面参数开启校验，那么请指定公钥文件地址。

第三步：按配置参数的路径挂载光盘，并把光盘挂载信息写入到/etc/fstab 文件中。

第四步：使用“yum install httpd -y”命令检查 Yum 软件仓库是否已经可用。

进入/etc/yum.repos.d 目录中后创建 Yum 配置文件：
[root@linuxprobe]# cd /etc/yum.repos.d/
[root@linuxprobe yum.repos.d]# vim rhel7.repo
[rhel7]
name=rhel7
baseurl=file:///media/cdrom
enabled=1
gpgcheck=0

创建挂载点后进行挂载操作，并设置成开机自动挂载（详见第 6 章）。尝试使用 Yum 软
件仓库来安装 Web 服务，出现 Complete！则代表配置正确：
[root@linuxprobe yum.repos.d]# mkdir -p /media/cdrom
[root@linuxprobe yum.repos.d]# mount /dev/cdrom /media/cdrom
mount: /dev/sr0 is write-protected, mounting read-only
[root@linuxprobe yum.repos.d]# vim /etc/fstab
/dev/cdrom /media/cdrom iso9660 defaults 0 0
[root@linuxprobe ~]# yum install httpd
Loaded plugins: langpacks, product-id, subscription-manager
………………省略部分输出信息………………
Dependencies Resolved
===============================================================================
Package Arch Version Repository Size
===============================================================================
Installing:
httpd x86_64 2.4.6-17.el7 rhel 1.2 M
Installing for dependencies:
apr x86_64 1.4.8-3.el7 rhel 103 k
apr-util x86_64 1.5.2-6.el7 rhel 92 k
httpd-tools x86_64 2.4.6-17.el7 rhel 77 k
mailcap noarch 2.1.41-2.el7 rhel 31 k
Transaction Summary
===============================================================================
Install 1 Package (+4 Dependent packages)
Total download size: 1.5 M
Installed size: 4.3 M
Is this ok [y/d/N]: y
Downloading packages:
-------------------------------------------------------------------------------
………………省略部分输出信息………………
Complete!


2. 编写shell脚本
可以将 Shell 终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与 Linux 系
统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程
语言才有的控制结构特性。要想正确使用 Shell 中的这些功能特性，准确下达命令尤为重要。
Shell 脚本命令的工作方式有两种：交互式和批处理。
➢ 交互式（Interactive）：用户每输入一条命令就立即执行。
➢ 批处理（Batch）：由用户事先编写好一个完整的 Shell 脚本，Shell 会一次性执行脚本
中诸多的命令。
在 Shell 脚本中不仅会用到前面学习过的很多 Linux 命令以及正则表达式、管道符、数据
流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所
见的 Shell 脚本。
查看 SHELL 变量可以发现当前系统已经默认使用 Bash 作为命令行终端解释器了：

## 2.1 编写简单的脚本
估计读者在看完上文中有关 Shell 脚本的复杂描述后，会累觉不爱吧。但是，上文指的是
一个高级 Shell 脚本的编写原则，其实使用 Vim 编辑器把 Linux 命令按照顺序依次写入到一
个文件中，这就是一个简单的脚本了。
例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这
个功能的脚本应该类似于下面这样：
vim example.sh
#!/bin/bash
#For Example BY linuxprobe.com
pwd
ls -al

Shell 脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh 后缀加上，以
表示是一个脚本文件。在上面的这个 example.sh 脚本中实际上出现了三种不同的元素：第一行的
脚本声明（#!）用来告诉系统使用哪种 Shell 解释器来执行该脚本；第二行的注释信息（#）是对
脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该
脚本的作用或一些警告信息；第三、四行的可执行语句也就是我们平时执行的 Linux 命令了。什
么？！你们不相信这么简单就编写出来了一个脚本程序，那我们来执行一下看看结果：
bash example.sh

除了上面用 bash 解释器命令直接运行 Shell 脚本文件外，第二种运行脚本程序的方法是
通过输入完整路径的方式来执行。但默认会因为权限不足而提示报错信息，此时只需要为脚
本文件增加执行权限即可（详见第 5 章）。初次学习 Linux 系统的读者不用心急，等下一章学
完用户身份和权限后再来做这个实验也不迟：
./example.sh

##2.1 接收用户的参数
但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板了。为了
让 Shell 脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能
够像之前执行命令时那样，接收用户输入的参数。
其实，Linux 系统中的 Shell 脚本语言早就考虑到了这些，已经内设了用于接收参数的变
量，变量之间可以使用空格间隔。例如$0 对应的是当前 Shell 脚本程序的名称，$#对应的是总共
有几个参数，$*对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值，而$1、
$2、$3……则分别对应着第 N 个位置的参数值

理论过后我们来练习一下。尝试编写一个脚本程序示例，通过引用上面的变量参数来看
下真实效果：
[root@linuxprobe ~]# vim example.sh
#!/bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数，分别是$*。"
echo "第 1 个参数为$1，第 5 个为$5。"
[root@linuxprobe ~]# sh example.sh one two three four five six
当前脚本名称为 example.sh
总共有 6 个参数，分别是 one two three four five six。
第 1 个参数为 one，第 5 个为 five。


##2.3 判断用户的参数
学习是一个登堂入室、由浅入深的过程。在学习完 Linux 命令、掌握 Shell 脚本语法变量
和接收用户输入的信息之后，就要踏上新的高度—能够进一步处理接收到的用户参数。
在本书前面章节中讲到，系统在执行 mkdir 命令时会判断用户输入的信息，即判断用户
指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell 脚本中的条
件测试语法可以判断表达式是否成立，若条件成立则返回数字 0，否则便返回其他随机数值。
条件测试语法的执行格式如图 4-16 所示。切记，条件表达式两边均应有一个空格([空格表达式空格])。

按照测试对象来划分，条件测试语句可以分为 4 种：
➢ 文件测试语句；
➢ 逻辑测试语句；
➢ 整数值比较语句；
➢ 字符串比较语句。

文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数
如下所示。
-d 测试文件是否为目录类型
-e 测试文件是否存在
-f 判断是否为一般文件
-r 测试当前用户是否有权限读取
-w 测试当前用户是否有权限写入
-x 测试当前用户是否有权限执行

下面使用文件测试语句来判断/etc/fstab 是否为一个目录类型的文件，然后通过 Shell 解释
器的内设$?变量显示上一条命令执行后的返回值。如果返回值为 0，则目录存在；如果返回值
为非零的值，则意味着目录不存在：
[root@linuxprobe ~]# [ -d /etc/fstab ]
[root@linuxprobe ~]# echo $?

逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在 Shell
终端中逻辑“与”的运算符号是&&，它表示当前面的命令执行成功后才会执行它后面的命令，
因此可以用来判断/dev/cdrom 文件是否存在，若存在则输出 Exist 字样。
[ -e /dev/cdrom ] && echo "Exist"

除了逻辑“与”外，还有逻辑“或”，它在 Linux 系统中的运算符号为||，表示当前面的命
令执行失败后才会执行它后面的命令，因此可以用来结合系统环境变量 USER 来判断当前登
录的用户是否为非管理员身份：
[root@linuxprobe ~]# echo $USER
root
[root@linuxprobe ~]# [ $USER = root ] || echo "user"
[root@linuxprobe ~]# su - linuxprobe
[linuxprobe@linuxprobe ~]$ [ $USER = root ] || echo "user"
user

第三种逻辑语句是“非”，在 Linux 系统中的运算符号是一个叹号（！），它表示把条件测
试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原
本测试错误的结果则将其变成正确的。
我们现在切换回到 root 管理员身份，再判断当前用户是否为一个非管理员的用户。由于
判断结果因为两次否定而变成正确，因此会正常地输出预设信息：
[ ! $USER = root ] || echo "administrator"

下面这个示例的执行顺序是，先判断当前
登录用户的 USER 变量名称是否等于 root，然后用逻辑运算符“非”进行取反操作，效果就
变成了判断当前登录的用户是否为非管理员用户了。最后若条件成立则会根据逻辑“与”运
算符输出 user 字样；或条件不满足则会通过逻辑“或”运算符输出 root 字样，而如果前面的
&&不成立才会执行后面的||符号。
[ ! $USER = root ] && echo "user" || echo "root"
root

整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且
不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲
突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规
范的整数比较运算符来进行操作。
可用的整数比较运算符：
-eq 是否等于
-ne 是否不等于
-gt 是否大于
-lt 是否小于
-le 是否等于或小于
-ge 是否大于或等于

我们先测试一下 10 是否大于 10（通过输出的返回值内容来判断）：
[root@linuxprobe ~]# [ 10 -gt 10 ]
[root@linuxprobe ~]# echo $?

在 2.4 节曾经讲过 free 命令，它可以用来获取当前系统正在使用及可用的内存量信息。
接下来先使用 free -m 命令查看内存使用量情况（单位为 MB），然后通过 grep Mem:命令过滤
出剩余内存量的行，再用 awk '{print $4}'命令只保留第四列，最后用 FreeMem=`语句`的方式
把语句内执行的结果赋值给变量。
这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。
FreeMem=`free -m | grep Mem: | awk '{print $4}'`
echo $FreeMem

上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不
用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于 1024，若小
于则会提示“Insufficient Memory”（内存不足）的字样：
[ $FreeMem -lt 1024 ] && echo "Insufficient Memory"

字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来
判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。
常见的字符串比较运算符：
= 比较字符串内容是否相同
!= 比较字符串内容是否不同
-z 判断字符串内容是否为空

接下来通过判断 String 变量是否为空值，进而判断是否定义了这个变量：
[root@linuxprobe ~]# [ -z $String]
[root@linuxprobe ~]# echo $?
0

再尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值 LANG 不是英语
（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样：
[ $LANG != "en.US" ] && echo "Not en.US"


3. 流程控制语句

##3.1 if条件测试语句
if 条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if 语
句分为单分支结构、双分支结构、多分支结构；其复杂度随着灵活度一起逐级上升。
if 条件语句的单分支结构由 if、then、fi 关键词组成，而且只在条件成立后才执行预设的
命令，相当于口语的“如果……那么……”。单分支的 if 语句属于最简单的一种条件判断结构。

下面使用单分支的 if 条件语句来判断/media/cdrom 文件是否存在，若存在就结束条件判
断和整个 Shell 脚本，反之则去创建这个目录：
[root@linuxprobe]# vim mkcdrom.sh
#!/bin/bash
DIR="/media/cdrom"
if [ ! -e $DIR ]
then
mkdir -p $DIR
fi

if 条件语句的双分支结构由 if、then、else、fi 关键词组成，它进行一次条件匹配判断，
如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口
语的“如果……那么……或者……那么……”。if 条件语句的双分支结构也是一种很简单的判
断结构。

下面使用双分支的 if 条件语句来验证某台主机是否在线，然后根据返回值的结果，要么
显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用 ping 命令来测试与对方
主机的网络联通性，而 Linux 系统中的 ping 命令不像 Windows 一样尝试 4 次就结束，因此为
了避免用户等待时间过长，需要通过-c 参数来规定尝试的次数，并使用-i 参数定义每个数据
包的发送间隔，以及使用-W 参数定义等待超时时间。
[root@linuxprobe]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ]
then
echo "Host $1 is On-line."
else
echo "Host $1 is Off-line."
fi

if 条件语句的多分支结构由 if、then、elif、else、fi 关键词组成，它进行多次条件匹配判
断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如
果……那么……如果……那么……”。if 条件语句的多分支结构是工作中最常使用的一种条件
判断结构，尽管相对复杂但是更加灵活

下面使用多分支的 if 条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如
Excellent、Pass、Fail 等提示信息。在 Linux 系统中，read 是用来读取用户输入信息的命令，
能够把接收到的用户输入信息赋值给后面的指定变量，-p 参数用于向用户显示一定的提示信
息。在下面的脚本示例中，只有当用户输入的分数大于等于 85 分且小于等于 100 分，才输出
Excellent 字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于 70 分
且小于等于 84 分，如果是，则输出 Pass 字样；若两次都落空（即两次的匹配操作都失败了），
则输出 Fail 字样：
[root@linuxprobe]# vim chkscore.sh
#!/bin/bash
read -p "Enter your score（0-100）：" GRADE
if [ $GRADE -ge 85 ] && [ $GRADE -le 100 ] ; then
echo "$GRADE is Excellent"
elif [ $GRADE -ge 70 ] && [ $GRADE -le 84 ] ; then
echo "$GRADE is Pass"
else
echo "$GRADE is Fail"
fi
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
[root@linuxprobe ~]# bash chkscore.sh
Enter your score（0-100）：80
80 is Pass

##3.2 for条件循环语句
for 循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理，当要处理的数据有范围时，
使用 for 循环语句再适合不过了。

语法格式：
for 变量名 in 取值列表
do
	命令序列
done

下面使用 for 循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设
置密码。首先创建用户名称的列表文件 users.txt，每个用户名称单独一行。读者可以自行决定
具体的用户名称和个数：
[root@linuxprobe]# vim users.txt
andy
barry
carl
duke
eric
georg

接下来编写 Shell 脚本 Example.sh。在脚本中使用 read 命令读取用户输入的密码值，然
后赋值给 PASSWD 变量，并通过-p 参数向用户显示一段提示信息，告诉用户正在输入的内容
即将作为账户密码。在执行该脚本后，会自动使用从列表文件 users.txt 中获取到所有的用户
名称，然后逐一使用“id 用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成
功，也就是判断该用户是否已经存在。
需要多说一句，/dev/null 是一个被称作 Linux 黑洞的文件，把输出信息重定向到这个文件等
同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。

[root@linuxprobe]# vim Example.sh
#!/bin/bash
read -p "Enter The Users Password : " PASSWD
for UNAME in `cat users.txt`
do
id $UNAME &> /dev/null
if [ $? -eq 0 ]
then
echo "Already exists"
else
useradd $UNAME &> /dev/null
echo "$PASSWD" | passwd --stdin $UNAME &> /dev/null
if [ $? -eq 0 ]
then
echo "$UNAME , Create success"
else
echo "$UNAME , Create failure"
fi
fi
done

执行批量创建用户的 Shell 脚本 Example.sh，在输入为账户设定的密码后将由脚本自
动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null 黑洞
文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create success）的提示后
不会有其他内容。
在 Linux 系统中，/etc/passwd 是用来保存用户账户信息的文件。如果想确认这个脚本是
否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。


让脚本从文本中自动读取主
机列表，然后自动逐个测试这些主机是否在线。
首先创建一个主机列表文件 ipadds.txt：
[root@linuxprobe]# vim ipadds.txt
192.168.10.10
192.168.10.11
192.168.10.12

然后前面的双分支 if 条件语句与 for 循环语句相结合，让脚本从主机列表文件 ipadds.txt
中自动读取 IP 地址（用来表示主机）并将其赋值给 HLIST 变量，从而通过判断 ping 命令执
行后的返回值来逐个测试主机是否在线。脚本中出现的$（命令）是一种完全类似于第 3 章的
转义字符中反引号`命令`的 Shell 操作符，效果同样是执行括号或双引号括起来的字符串中的
命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：
[root@linuxprobe]# vim CheckHosts.sh
#!/bin/bash
HLIST=$(cat ~/ipadds.txt)
for IP in $HLIST
do
ping -c 3 -i 0.2 -W 3 $IP &> /dev/null
if [ $? -eq 0 ] ; then
echo "Host $IP is On-line."
else
echo "Host $IP is Off-line."
fi
done
[root@linuxprobe ~]# ./CheckHosts.sh
Host 192.168.10.10 is On-line.
Host 192.168.10.11 is Off-line.
Host 192.168.10.12 is Off-line.


##3.3 while条件循环语句
while 条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往
往在执行前并不确定最终执行的次数，完全不同于 for 循环语句中有目标、有范围的使用场
景。while 循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执
行，为假就结束循环。

语法格式：
while 条件测试操作
do
	命令序列
done

接下来结合使用多分支的 if 条件测试语句与 while 条件循环语句，编写一个用来猜测数值大
小的脚本 Guess.sh。该脚本使用$RANDOM 变量来调取出一个随机的数值（范围为 0～32767），
将这个随机数对 1000 进行取余操作，并使用 expr 命令取得其结果，再用这个数值与用户通过 read
命令输入的数值进行比较判断。这个判断语句分为三种情况，分别是判断用户输入的数值是等于、
大于还是小于使用 expr 命令取得的数值。当前，现在这些内容不是重点，我们当前要关注的是
while 条件循环语句中的条件测试始终为 true，因此判断语句会无限执行下去，直到用户输入的数
值等于 expr 命令取得的数值后，这两者相等之后才运行 exit 0 命令，终止脚本的执行。
[root@linuxprobe ~]# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo "商品实际价格为 0-999 之间，猜猜看是多少？"
while true
do
read -p "请输入您猜测的价格数目：" INT
let TIMES++
if [ $INT -eq $PRICE ] ; then
echo "恭喜您答对了，实际价格是 $PRICE"
echo "您总共猜 g $TIMES 次"
exit 0
elif [ $INT -gt $PRICE ] ; then
echo "太高了！"
else
echo "太低了！"
fi
done


##3.4 case条件测试语句
如果您之前学习过 C 语言，看到这一小节的标题肯定会会心一笑“这不就是 switch 语句
嘛！”是的，case 条件测试语句和 switch 语句的功能非常相似！case 语句是在多个范围内匹配
数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，
则会去执行星号（*）中所定义的默认命令。c


语法格式：
case 变量值 in
模式1)
	命令序列1
	;;
模式2)
	命令序列2
	;;
	......
*)
	默认命令序列
esac

在前文介绍的 Guess.sh 脚本中有一个致命的弱点—只能接受数字！您可以尝试输入一
个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a 是否大
于等于 3”这样的命题是完全错误的。我们必须有一定的措施来判断用户的输入内容，当用户
输入的内容不是数字时，脚本能予以提示，从而免于崩溃。
通过在脚本中组合使用 case 条件测试语句和通配符（详见第 3 章），完全可以满足这里
的需求。接下来我们编写脚本 Checkkeys.sh，提示用户输入一个字符并将其赋值给变量 KEY，
然后根据变量 KEY 的值向用户显示其值是字母、数字还是其他字符。

[root@linuxprobe ~]# vim Checkkeys.sh
#!/bin/bash
read -p "请输入一个字符，并按 Enter 键确认：" KEY
case "$KEY" in
[a-z]|[A-Z])
echo "您输入的是 字母。"
;;
[0-9])
echo "您输入的是 数字。"
;;
*)
echo "您输入的是 空格、功能键或其他控制字符。"
esac
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按 Enter 键确认：6
您输入的是 数字。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按 Enter 键确认：p
您输入的是 字母。
[root@linuxprobe ~]# bash Checkkeys.sh
请输入一个字符，并按 Enter 键确认：^[[15~
您输入的是 空格、功能键或其他控制字符。



4. 计划任务服务程序
经验丰富的系统运维工程师可以使得 Linux 在无需人为介入的情况下，在指定的时间段自动
启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程
序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本
程序，这简直太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向
大家讲解如何设置服务器的计划任务服务，把周期性、规律性的工作交给系统自动完成。
计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解。
➢ 一次性计划任务：今晚 11 点 30 分开启网站服务。
➢ 长期性计划任务：每周一的凌晨 3 点 25 分把/home/wwwroot 目录打包备份为
backup.tar.gz。
顾名思义，一次性计划任务只执行一次，一般用于满足临时的工作需求。我们可以用 at
命令实现这种功能，只需要写成“at 时间”的形式就可以。如果想要查看已设置好但还未执
行的一次性计划任务，可以使用“at -l”命令；要想将其删除，可以用“atrm 任务序号”。在
使用 at 命令来设置一次性计划任务时，默认采用的是交互式方法。例如，使用下述命令将系
统设置为在今晚 23:30 分自动重启网站服务。

[root@linuxprobe ~]# at 23:30
at > systemctl restart httpd
at > 此处请同时按下 Ctrl + D 组合键来结束编写计划任务
job 3 at Mon Apr 27 23:30:00 2017
[root@linuxprobe ~]# at -l
3 Mon Apr 27 23:30:00 2017 a root

如果读者想挑战一下难度更大但简捷性更高的方式，可以把前面学习的管道符（任意门）
放到两条命令之间，让 at 命令接收前面 echo 命令的输出信息，以达到通过非交互式的方式创
建计划一次性任务的目的。
[root@linuxprobe ~]# echo "systemctl restart httpd" | at 23:30
job 4 at Mon Apr 27 23:30:00 2017
[root@linuxprobe ~]# at -l
3 Mon Apr 27 23:30:00 2017 a root
4 Mon Apr 27 23:30:00 2017 a root

如果我们不小心设置了两个一次性计划任务，可以使用下面的命令轻松删除其中一个：
[root@linuxprobe ~]# atrm 3
[root@linuxprobe ~]# at -l
4 Mon Apr 27 23:30:00 2017 a root

如果我们希望 Linux 系统能够周期性地、有规律地执行某些具体的任务，那么 Linux 系统
中默认启用的 crond 服务简直再适合不过了。创建、编辑计划任务的命令为“crontab -e”，查看
当前计划任务的命令为“crontab -l”，删除某条计划任务的命令为“crontab -r”。另外，如果您是
以管理员的身份登录的系统，还可以在 crontab 命令中加上-u 参数来编辑他人的计划任务。
在正式部署计划任务前，请先跟刘遄老师念一下口诀“分、时、日、月、星期 命令”。
这是使用 crond 服务设置任务的参数格式（其格式见表 4-6）。需要注意的是，如果有些字段
没有设置，则需要使用星号（*）占位

使用 crond 设置任务的参数字段说明:
分 取值为 0～59 的整数
时 取值为 0～23 的任意整数
日 取值为 1～31 的任意整数
月 取值为 1～12 的任意整数
星期 取值为 0～7 的任意整数，其中 0 与 7 均为星期日
命令 要执行的命令或程序脚本

假设在每周一、三、五的凌晨 3 点 25 分，都需要使用 tar 命令把某个网站的数据目录进
行打包处理，使其作为一个备份文件。我们可以使用 crontab -e 命令来创建计划任务。为自己
创建计划任务无需使用-u 参数，具体的实现效果的参数如 crontab -l 命令结果所示：
[root@linuxprobe ~]# crontab -e
no crontab for root - using an empty one
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot

需要说明的是，除了用逗号（,）来分别表示多个时间段，例如“8,9,12”表示 8 月、9 月
和 12 月。还可以用减号（-）来表示一段连续的时间周期（例如字段“日”的取值为“12-15”，
则表示每月的 12～15 日）。以及用除号（/）表示执行任务的间隔时间（例如“*/2”表示每隔
2 分钟执行一次任务）。
如果在 crond 服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如我们再
添加一条计划任务，它的功能是每周一至周五的凌晨 1 点钟自动清空/tmp 目录内的所有文件。尤
其需要注意的是，在 crond 服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如
果不知道绝对路径，请用 whereis 命令进行查询，rm 命令路径为下面输出信息中加粗部分。

[root@linuxprobe ~]# whereis rm
rm: /usr/bin/rm /usr/share/man/man1/rm.1.gz /usr/share/man/man1p/rm.1p.gz
[root@linuxprobe ~]# crontab -e
crontab: installing new crontab
[root@linuxprobe ~]# crontab -l
25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot
0 1 * * 1-5 /usr/bin/rm -rf /tmp/*

在本节最后，刘遄老师再来啰嗦几句在工作中使用计划服务的注意事项。
➢ 在 crond 服务的配置参数中，可以像 Shell 脚本那样以#号开头写上注释信息，这样
在日后回顾这段命令代码时可以快速了解其功能、需求以及编写人员等重要信息。
➢ 计划任务中的“分”字段必须有数值，绝对不能为空或是*号，而“日”和“星期”字
段不能同时使用，否则就会发生冲突。
最后再啰嗦一句，想必读者也已经发现了，诸如 crond 在内的很多服务默认调用的是 Vim
编辑器，相信大家现在能进一步体会到在 Linux 系统中掌握 Vim 文本编辑器的好处了吧。所
以请大家一定要在彻底掌握 Vim 编码器之后再学习下一章。






