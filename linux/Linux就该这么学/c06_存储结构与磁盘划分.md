本章讲解了如下内容：
➢ 一切从“/”开始；
➢ 物理设备的命名规则；
➢ 文件系统与数据资料；
➢ 挂载硬件设备；
➢ 添加硬件设备；
➢ 添加交换分区；
➢ 磁盘容量配额；
➢ 软硬方式链接。
Linux 系统中颇具特色的文件存储结构常常搞得新手头晕脑胀，本章将从 Linux 系统中的
文件存储结构开始，讲述文件系统层次化标准（FHS，Filesystem Hierarchy Standard）、udev 硬
件命名规则以及硬盘分区的规划方法。
为了让读者更好地理解文件系统的作用，刘遄老师将在本章中详细地分析 Linux 系统中
最常见的 Ext3、Ext4 与 XFS 文件系统的不同之处，并带领各位读者着重练习硬盘设备分区、
格式化以及挂载等常用的硬盘管理操作，以便熟练掌握文件系统的使用方法。
在打下坚实的理论基础与完成一些相关的实践练习后，我们将进一步完整地部署 SWAP
交换分区、配置 quota 磁盘配额服务，以及掌握 ln 命令带来的软硬链接。相信各位读者在学
习完本章后，会对 Linux 系统以及 Windows 系统中的磁盘存储以及文件系统有深入的理解。

1. 一切从“/”开始
在 Linux 系统中，目录、字符设备、块设备、套接字、打印机等都被抽象成了文件，即刘遄
老师所一直强调的“Linux 系统中一切都是文件”。既然平时我们打交道的都是文件，那么又应该
如何找到它们呢？在 Windows 操作系统中，想要找到一个文件，我们要依次进入该文件所在的磁
盘分区（假设这里是 D 盘），然后在进入该分区下的具体目录，最终找到这个文件。但是在 Linux
系统中并不存在 C/D/E/F 等盘符，Linux 系统中的一切文件都是从“根（/）”目录开始的，并按照
文件系统层次化标准（FHS）采用树形结构来存放文件，以及定义了常见目录的用途。另外，Linux
系统中的文件和目录名称是严格区分大小写的。例如，root、rOOt、Root、rooT 均代表不同的目
录，并且文件名称中不得包含斜杠（/）。Linux 系统中的文件存储结构如图 6-1 所示。

根目录/
------/root
------/bin
------/boot
------------/root/Desktop
------------/root/Media
------/dev
------/etc
------/home
------/var
------/lib
------/usr
------------/usr/bin
------------/usr/lib
------/media
------/tmp
...

前文提到的 FHS 是根据以往无数 Linux 系统用户和开发者的经验而总结出来的，是用户
在 Linux 系统中存储文件时需要遵守的规则，用于指导我们应该把文件保存到什么位置，以
及告诉用户应该在何处找到所需的文件。但是，FHS 对于用户来讲只能算是一种道德上的约
束，有些用户就是懒得遵守，依然会把文件到处乱放，有些甚至从来没有听说过它。这里并不
是号召各位读者去谴责他们，而是建议大家要灵活运用所学的知识，千万不要认准这个 FHS
协定只讲死道理，不然吃亏的可就是自己了。在 Linux 系统中，最常见的目录以及所对应的
存放内容如表 6-1 所示。

Linux 系统中常见的目录名称以及相应内容:
/boot 开机所需文件—内核、开机菜单以及所需配置文件等
/dev 以文件形式存放任何设备与接口
/etc 配置文件
/home 用户家目录
/bin 存放单用户模式下还可以操作的命令
/lib 开机时用到的函数库，以及/bin 与/sbin 下面的命令要调用的函数
/sbin 开机过程中需要的命令
/media 用于挂载设备文件的目录
/opt 放置第三方的软件
/root 系统管理员的家目录
/srv 一些网络服务的数据文件目录
/tmp 任何人均可使用的“共享”临时目录
/proc 虚拟文件系统，例如系统内核、进程、外部设备及网络状态等
/usr/local 用户自行安装的软件
/usr/sbin Linux 系统开机时不会使用到的软件/命令/脚本
/usr/share 帮助与说明文件，也可放置共享文件
/var 主要存放经常变化的文件，如日志
/lost+found 当文件系统发生错误时，将一些丢失的文件片段存放在这里

在 Linux 系统中另外还有一个重要的概念—路径。路径指的是如何定位到某个文件，
分为绝对路径与相对路径。绝对路径指的是从根目录（/）开始写起的文件或目录名称，而相
对路径则指的是相对于当前路径的写法。我们来看下面这个例子，以帮助大家理解。假如有
位外国游客来到中国潘家园旅游，当前内急但是找不到洗手间，特意向您问路，那么您有两
种正确的指路方法。
➢ 绝对路径：首先坐飞机来到中国，到了北京出首都机场坐机场快轨到
三元桥，然后换乘 10 号线到潘家园站，出站后坐 34 路公交车到农光里，下车后路口
左转。
➢ 相对路径：前面路口左转。

2. 物理设备的命名规则
在 Linux 系统中一切都是文件，硬件设备也不例外。既然是文件，就必须有文件名称。
系统内核中的 udev 设备管理器会自动把硬件名称规范起来，目的是让用户通过设备文件的名
字可以猜出设备大致的属性以及分区信息等；这对于陌生的设备来说特别方便。另外，udev
设备管理器的服务会一直以守护进程的形式运行并侦听内核发出的信号来管理/dev 目录下的
设备文件。Linux 系统中常见的硬件设备的文件名称如表 6-2 所示。
常见的硬件设备及其文件名称：
IDE 设备 /dev/hd[a-d]
SCSI/SATA/U 盘 /dev/sd[a-p]
软驱 /dev/fd[0-1]
打印机 /dev/lp[0-15]
光驱 /dev/cdrom
鼠标 /dev/mouse
磁带机 /dev/st0 或/dev/ht0

由于现在的 IDE 设备已经很少见了，所以一般的硬盘设备都会是以“/dev/sd”开头的。

而一台主机上可以有多块硬盘，因此系统采用 a～p 来代表 16 块不同的硬盘（默认从 a 开始
分配），而且硬盘的分区编号也很有讲究：
➢ 主分区或扩展分区的编号从 1 开始，到 4 结束；
➢ 逻辑分区从编号 5 开始。
国内很多 Linux 培训讲师以及很多知名 Linux 图书在讲到设备和分区名称时，总会讲错
两个知识点。第一个知识点是设备名称的理解错误。很多培训讲师和 Linux 技术图书中会提
到，比如/dev/sda 表示主板上第一个插槽上的存储设备，学员或读者在实践操作的时候会发现
果然如此，因此也就对这条理论知识更加深信不疑。但真相不是这样的，/dev 目录中 sda 设备
之所以是 a，并不是由插槽决定的，而是由系统内核的识别顺序来决定的，而恰巧很多主板的
插槽顺序就是系统内核的识别顺序，因此才会被命名为/dev/sda。大家以后在使用 iSCSI 网络
存储设备时就会发现，明明主板上第二个插槽是空着的，但系统却能识别到/dev/sdb 这个设备
就是这个道理。
第二个知识点是对分区名称的理解错误。很多 Linux 培训讲师会告诉学员，分区的编号
代表分区的个数。比如 sda3 表示这是设备上的第三个分区，而学员在做实验的时候确实也会
得出这样的结果，但是这个理论知识是错误的，因为分区的数字编码不一定是强制顺延下来
的，也有可能是手工指定的。因此 sda3 只能表示是编号为 3 的分区，而不能判断 sda 设备上
已经存在了 3 个分区。

在填了这两个“坑”之后，刘遄老师再来分析一下/dev/sda5 这个设备文件名称包含哪些
信息，如图 6-2 所示。

首先，/dev/目录中保存的应当是硬件设备文件；其次，sd 表示是存储设备；然后，a 表示
系统中同类接口中第一个被识别到的设备，最后，5 表示这个设备是一个逻辑分区。一言以蔽
之，“/dev/sda5”表示的就是“这是系统中第一块被识别到的硬件设备中分区编号为 5 的逻辑
分区的设备文件”。考虑到我们的很多读者完全没有 Linux 基础，不太容易理解前面所说的主
分区、扩展分区和逻辑分区的概念，因此接下来简单科普一下硬盘相关的知识。
正是因为计算机有了硬盘设备，我们才可以在玩游戏的过程中或游戏通关之后随时存档，
而不用每次重头开始。硬盘设备是由大量的扇区组成的，每个扇区的容量为 512 字节。其中
第一个扇区最重要，它里面保存着主引导记录与分区表信息。就第一个扇区来讲，主引导记
录需要占用 446 字节，分区表为 64 字节，结束符占用 2 字节；其中分区表中每记录一个分区
信息就需要 16 字节，这样一来最多只有 4 个分区信息可以写到第一个扇区中，这 4 个分区就
是 4 个主分区。

现在，问题来了—第一个扇区最多只能创建出 4 个分区？于是为了解决分区个数不够
的问题，可以将第一个扇区的分区表中 16 字节（原本要写入主分区信息）的空间（称之为扩
展分区）拿出来指向另外一个分区。也就是说，扩展分区其实并不是一个真正的分区，而更像
是一个占用 16 字节分区表空间的指针—一个指向另外一个分区的指针。这样一来，用户一
般会选择使用 3 个主分区加 1 个扩展分区的方法，然后在扩展分区中创建出数个逻辑分区，
从而来满足多分区（大于 4 个）的需求。当然，就目前来讲大家只要明白为什么主分区不能
超过 4 个就足够了。主分区、扩展分区、逻辑分区可以像图 6-4 那样来规划。


3. 文件系统与数据资料
用户在硬件存储设备中执行的文件建立、写入、读取、修改、转存与控制等操作都是依
靠文件系统来完成的。文件系统的作用是合理规划硬盘，以保证用户正常的使用需求。Linux
系统支持数十种的文件系统，而最常见的文件系统如下所示。
➢ ：是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能
自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很
长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入动作
的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分，然
后尝试进行修复。
➢ ：Ext3 的改进版本，作为 RHEL 6 系统中的默认文件管理系统，它支持的存储容
量高达 1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4 文件系
统能够批量分配 block 块，从而极大地提高了读写效率。
➢ ：是一种高性能的日志文件系统，而且是 RHEL 7 中默认的文件管理系统，它的
优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的
日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为 18EB，
这几乎满足了所有需求

RHEL 7 系统中一个比较大的变化就是使用了 XFS 作为文件系统，这不同于 RHEL 6 使
用的 Ext4。从红帽公司官方发布的说明来看，这确实是一个不小的进步，但是刘遄老师在实
测中发现并不完全属实。因为单纯就测试一款文件系统的“读取”性能来说，到底要读取多少
个文件，每个文件的大小是多少，读取文件时的 CPU、内存等系统资源的占用率如何，以及
不同的硬件配置是否会有不同的影响，因此在充分考虑到这些不确定因素后，实在不敢直接
照抄红帽官方的介绍。我个人认为 XFS 虽然在性能方面比 Ext4 有所提升，但绝不是压倒性
的，因此 XFS 文件系统最卓越的亮点应该当属可支持高达 18EB 的存储容量吧。
就像拿到了一张未裁切的完整纸张那样，我们首先要进行裁切以方便使用，然后在裁切后
的纸张上画格以便能书写工整。在拿到了一块新的硬盘存储设备后，也需要先分区，然后再格
式化文件系统，最后才能挂载并正常使用。硬盘的分区操作取决于您的需求和硬盘大小；您也
可以选择不进行分区，但是必须对硬盘进行格式化处理。接下来刘遄老师再向大家简单地科普
一下硬盘在格式化后发生的事情。再次强调，不用刻意去记住，只要能看懂就行了。

日常在硬盘需要保存的数据实在太多了，因此 Linux 系统中有一个名为 super block 的“硬
盘地图”。Linux 并不是把文件内容直接写入到这个“硬盘地图”里面，而是在里面记录着整
个文件系统的信息。因为如果把所有的文件内容都写入到这里面，它的体积将变得非常大，
而且文件内容的查询与写入速度也会变得很慢。Linux 只是把每个文件的权限与属性记录在
inode 中，而且每个文件占用一个独立的 inode 表格，该表格的大小默认为 128 字节，里面记
录着如下信息：
➢ 该文件的访问权限（read、write、execute）；
➢ 该文件的所有者与所属组（owner、group）；
➢ 该文件的大小（size）；
➢ 该文件的创建或内容修改时间（ctime）；
➢ 该文件的最后一次访问时间（atime）；
➢ 该文件的修改时间（mtime）；
➢ 文件的特殊权限（SUID、SGID、SBIT）；
➢ 该文件的真实数据地址（point）。

而文件的实际内容则保存在 block 块中（大小可以是 1KB、2KB 或 4KB），一个 inode 的
默认大小仅为 128B（Ext3），记录一个 block 则消耗 4B。当文件的 inode 被写满后，Linux 系
统会自动分配出一个 block 块，专门用于像 inode 那样记录其他 block 块的信息，这样把各个
block 块的内容串到一起，就能够让用户读到完整的文件内容了。对于存储文件内容的 block
块，有下面两种常见情况（以 4KB 的 block 大小为例进行说明）。
➢ 情况 1：文件很小（1KB），但依然会占用一个 block，因此会潜在地浪费 3KB。
➢ 情况 2：文件很大（5KB），那么会占用两个 block（5KB-4KB 后剩下的 1KB 也要占
用一个 block）。
计算机系统在发展过程中产生了众多的文件系统，为了使用户在读取或写入文件时不用
关心底层的硬盘结构，Linux 内核中的软件层为用户程序提供了一个 VFS（Virtual File System，
虚拟文件系统）接口，这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作
了。图 6-5 所示为 VFS 的架构示意图。从中可见，实际文件系统在 VFS 下隐藏了自己的特性
和细节，这样用户在日常使用时会觉得“文件系统都是一样的”，也就可以随意使用各种命令
在任何文件系统中进行各种操作了（比如使用 cp 命令来复制文件）。


4. 挂载硬件设备
我们在用惯了 Windows 系统后总觉得一切都是理所当然的，平时把 U 盘插入到电脑后
也从来没有考虑过 Windows 系统做了哪些事情，才使得我们可以访问这个 U 盘的。接下来
我们会逐一学习在 Linux 系统中挂载和卸载存储设备的方法，以便大家更好地了解 Linux 系
统添加硬件设备的工作原理和流程。前面讲到，在拿到一块全新的硬盘存储设备后要先分区，
然后格式化，最后才能挂载并正常使用。“分区”和“格式化”大家以前经常听到，但“挂
载”又是什么呢？刘遄老师在这里给您一个最简单、最贴切的解释—当用户需要使用硬盘
设备或分区中的数据时，需要先将其与一个已存在的目录文件进行关联，而这个关联动作就
是“挂载”。下文将向读者逐步讲解如何使用硬盘设备，但是鉴于与挂载相关的理论知识比
较复杂，而且很重要，因此决定再拿出一个小节单独讲解，这次希望大家不仅要看懂，而且
还要记住。

##4.1 mount 命令
mount 命令用于挂载文件系统，格式为“mount 文件系统 挂载目录”。mount 命令中可用
的参数及作用如表 6-3 所示。挂载是在使用硬件设备前所执行的最后一步操作。只需使用
mount 命令把硬盘设备或分区与一个目录文件进行关联，然后就能在这个目录中看到硬件设
备中的数据了。对于比较新的 Linux 系统来讲，一般不需要使用-t 参数来指定文件系统的类
型，Linux 系统会自动进行判断。而 mount 中的-a 参数则厉害了，它会在执行后自动检查
/etc/fstab 文件中有无疏漏被挂载的设备文件，如果有，则进行自动挂载操作。

mount 命令中的参数以及作用:
-a 挂载所有在/etc/fstab 中定义的文件系统
-t 指定文件系统的类型

例如，要把设备/dev/sdb2 挂载到/backup 目录，只需要在 mount 命令中填写设备与挂载目录
参数就行，系统会自动去判断要挂载文件的类型，因此只需要执行下述命令即可：
[root@linuxprobe]# mount /dev/sdb2 /backup

虽然按照上面的方法执行 mount 命令后就能立即使用文件系统了，但系统在重启后挂
载就会失效，也就是说我们需要每次开机后都手动挂载一下。这肯定不是我们想要的效果，
如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式
“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”（各字段的意义见表 6-4）
写入到/etc/fstab 文件中。这个文件中包含着挂载所需的诸多信息项目，一旦配置好之后就
能一劳永逸了。

用于挂载信息的指定填写格式中，各字段所表示的意义
设备文件  一般为设备的路径 + 设备名称 ，也可以写唯一识别码（UUID ，niversally Unique Identifier）
挂载目录 指定要挂载到的目录，需在挂载前创建好
格式类型 指定文件系统的格式，比如 Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等
权限选项 若设置为 defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async
是否备份 若为 1 则开机后使用 dump 进行磁盘备份，为 0 则不备份
是否自检 若为 1 则开机后自动进行磁盘自检，为 0 则不自检

如果想将文件系统为 ext4 的硬件设备/dev/sdb2 在开机后自动挂载到/backup 目录上，并
保持默认权限且无需开机自检，就需要在/etc/fstab 文件中写入下面的信息，这样在系统重启
后也会成功挂载。
[root@linuxprobe]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Wed May 4 19:26:23 2017
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/rhel-root / xfs defaults 1 1
UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2
/dev/mapper /rhel-swap swap swap defaults 0 0
/dev/cdrom /media/cdrom iso9660 defaults 0 0
/dev/sdb2 /backup ext4 defaults 0 0

##4.2 umount 命令
umount 命令用于撤销已经挂载的设备文件，格式为“umount [挂载点/设备文件]”。我们
挂载文件系统的目的是为了使用硬件资源，而卸载文件系统就意味不再使用硬件的设备资源；
相对应地，挂载操作就是把硬件设备与目录进行关联的动作，因此卸载操作只需要说明想要
取消关联的设备文件或挂载目录的其中一项即可，一般不需要加其他额外的参数。我们来尝
试手动卸载掉/dev/sdb2 设备文件：
[root@linuxprobe]# umount /dev/sdb2


5. 添加硬盘设备

6. 添加交换分区

7. 磁盘容量配额

8. 软硬方式链接








